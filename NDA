import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression
from scipy.optimize import curve_fit

# ----------------------------
# 데이터 생성 (예시)
# ----------------------------
np.random.seed(42)
x_true = np.linspace(0, 10, 100)

y_true1 = np.sin(x_true) * 4
y_true2 = 0.2*x_true**3 - 1.5*x_true**2 + 0.5*x_true + 5
y_true3 = 10 * np.exp(-0.3*x_true)

x_all = np.concatenate([x_true, x_true, x_true])
y_all = np.concatenate([y_true1 + np.random.normal(0,0.5,len(x_true)),
                        y_true2 + np.random.normal(0,1.0,len(x_true)),
                        y_true3 + np.random.normal(0,0.8,len(x_true))])

# 무작위 순서로 섞기
perm = np.random.permutation(len(x_all))
x_stream = x_all[perm]
y_stream = y_all[perm]

# ----------------------------
# Generic Model (Poly/Sine/Exp)
# ----------------------------
class GenericModel:
    def __init__(self, family='poly', degree=3):
        self.family = family
        self.degree = degree
        self.params = None
        self.sigma = None
        self.x_range = None

    def fit(self, x, y):
        x = np.array(x); y = np.array(y)
        if len(x) < 3:
            return False
        self.x_range = (min(x), max(x))
        try:
            if self.family == 'poly':
                X = PolynomialFeatures(self.degree).fit_transform(x.reshape(-1,1))
                lr = LinearRegression().fit(X,y)
                self.params = lr
                self.sigma = np.std(y - lr.predict(X))
            elif self.family == 'sine':
                def sfunc(xx,A,B,C,D): return A*np.sin(B*xx+C)+D
                p0 = [np.ptp(y)/2, 1.0, 0.0, np.mean(y)]
                popt,_ = curve_fit(sfunc,x,y,p0=p0,maxfev=5000)
                self.params = popt
                self.sigma = np.std(y - sfunc(x,*popt))
            elif self.family == 'exp':
                def efunc(xx,A,B,C): return A*np.exp(B*xx)+C
                p0 = [y[0]-y[-1], -0.2, np.mean(y)]
                popt,_ = curve_fit(efunc,x,y,p0=p0,maxfev=5000)
                self.params = popt
                self.sigma = np.std(y - efunc(x,*popt))
            return True
        except:
            return False

    def predict(self, x):
        x = np.array(x)
        if self.family == 'poly' and self.params is not None:
            X = PolynomialFeatures(self.degree).fit_transform(x.reshape(-1,1))
            return self.params.predict(X)
        if self.family == 'sine' and self.params is not None:
            A,B,C,D = self.params
            return A*np.sin(B*x + C) + D
        if self.family == 'exp' and self.params is not None:
            A,B,C = self.params
            return A*np.exp(B*x) + C
        return np.full_like(x,np.nan,dtype=float)

    def residuals(self, x, y):
        return np.abs(y - self.predict(x))

# ----------------------------
# Adaptive Mixture
# ----------------------------
class AdaptiveFitter:
    def __init__(self, threshold=2.0):
        self.models = []
        self.threshold = threshold

    def assign_points(self, x, y):
        assignments = np.full(len(x), -1)
        for i, (xi, yi) in enumerate(zip(x,y)):
            best_model = None
            min_resid = np.inf
            for k, m in enumerate(self.models):
                if m.x_range[0] <= xi <= m.x_range[1]:
                    r = m.residuals([xi],[yi])[0]
                    if r < min_resid:
                        min_resid = r
                        best_model = k
            if min_resid <= self.threshold:
                assignments[i] = best_model
        return assignments

    def refit_models(self, x, y, assignments):
        new_models = []
        for k, m in enumerate(self.models):
            mask = (assignments == k)
            if np.sum(mask) >= 3:
                mm = GenericModel(family=m.family, degree=m.degree)
                mm.fit(x[mask], y[mask])
                new_models.append(mm)
        self.models = new_models

    def add_new_model_if_needed(self, x, y, assignments):
        unassigned_mask = (assignments == -1)
        if np.sum(unassigned_mask) < 5:
            return
        xu = x[unassigned_mask]
        yu = y[unassigned_mask]

        # 새 모델 생성: 다항/사인/지수 중 랜덤 선택
        family_choice = np.random.choice(['poly','sine','exp'])
        new_model = GenericModel(family=family_choice, degree=3)
        if new_model.fit(xu, yu):
            self.models.append(new_model)

# ----------------------------
# 애니메이션
# ----------------------------
fig, ax = plt.subplots(figsize=(9,5))
ax.set_xlim(0,10)
ax.set_ylim(min(y_all)-3, max(y_all)+3)
scatter = ax.scatter([], [], s=16)
lines = []
txt = ax.text(0.01,0.98,"", transform=ax.transAxes, va="top")

fitter = AdaptiveFitter(threshold=2.0)

def init():
    scatter.set_offsets(np.empty((0,2)))
    for ln in lines:
        ln.remove()
    lines.clear()
    txt.set_text("")
    return scatter, txt

def update(frame):
    x = x_stream[:frame+1]
    y = y_stream[:frame+1]
    scatter.set_offsets(np.c_[x,y])

    assignments = fitter.assign_points(x, y)
    fitter.refit_models(x, y, assignments)
    fitter.add_new_model_if_needed(x, y, assignments)

    for ln in lines:
        ln.remove()
    lines.clear()

    xs_plot = np.linspace(0,10,300)
    for m in fitter.models:
        yhat = m.predict(xs_plot)
        ln, = ax.plot(xs_plot, yhat,lw=2)
        lines.append(ln)

    txt.set_text(f"Frame={frame+1}, models={len(fitter.models)}, unassigned={np.sum(assignments==-1)}")
    return scatter, txt, *lines

ani = FuncAnimation(fig, update, frames=len(x_stream),
                    init_func=init, interval=80, blit=False, repeat=False)

plt.show()
